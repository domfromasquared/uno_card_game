<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>UNO-like Card Game</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #16171b;
      color: #f5f5f5;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
    }

    .game {
      background: #1f2127;
      border-radius: 12px;
      padding: 20px 24px 28px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      max-width: 900px;
      width: 100%;
    }

    h1 {
      margin-top: 0;
      text-align: center;
      letter-spacing: 1px;
    }

    #status {
      text-align: center;
      margin-bottom: 12px;
      font-size: 1rem;
      min-height: 1.5em;
    }

    .board {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 20px;
      align-items: center;
    }

    .pile {
      text-align: center;
    }

    .pile-title {
      margin-bottom: 6px;
      font-size: 0.9rem;
      opacity: 0.7;
    }

    #deckCount {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 4px;
    }

    .card-slot {
      width: 80px;
      height: 120px;
      border-radius: 10px;
      border: 2px dashed #444;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      background: #3b82f6;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      background: #2563eb;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .hand {
      margin-bottom: 16px;
    }

    .hand h2 {
      margin: 8px 0;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .cards-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 130px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.02);
    }

    .card {
      width: 70px;
      height: 100px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 1.2rem;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      border: 3px solid #f5f5f5;
      box-sizing: border-box;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    .card.player-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
      filter: brightness(1.05);
    }

    .card .value {
      text-shadow: 0 2px 3px rgba(0, 0, 0, 0.6);
    }

    .card.action .value {
      font-size: 1rem;
      text-align: center;
      padding: 0 4px;
    }

    .card.red {
      background: #ef4444;
    }

    .card.yellow {
      background: #eab308;
      color: #111827;
    }

    .card.green {
      background: #22c55e;
    }

    .card.blue {
      background: #3b82f6;
    }

    .card.back {
      background: linear-gradient(135deg, #111827, #020617);
      border-color: #e5e7eb;
      color: #e5e7eb;
      font-size: 1rem;
      letter-spacing: 1px;
      cursor: default;
    }

    .card.back::before {
      content: "";
      position: absolute;
      inset: 5px;
      border-radius: 8px;
      border: 2px solid #e5e7eb;
      opacity: 0.75;
    }

    #newGameBtn {
      display: block;
      margin: 12px auto 0;
    }

    @media (max-width: 700px) {
      .board {
        flex-direction: column;
        gap: 16px;
      }
      .card {
        width: 58px;
        height: 85px;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="game">
    <h1>UNO-like Card Game</h1>
    <div id="status"></div>

    <div class="board">
      <div class="pile">
        <div class="pile-title">Draw pile</div>
        <button id="drawButton">Draw card</button>
        <div id="deckCount"></div>
      </div>

      <div class="pile">
        <div class="pile-title">Discard pile</div>
        <div id="discardTop" class="card-slot"></div>
      </div>
    </div>

    <div class="hand cpu-hand">
      <h2>
        CPU Hand
        <span>(<span id="cpuCount">0</span> cards)</span>
      </h2>
      <div id="cpuCards" class="cards-row"></div>
    </div>

    <div class="hand player-hand">
      <h2>Your Hand</h2>
      <div id="playerCards" class="cards-row"></div>
    </div>

    <button id="newGameBtn">New Game</button>
  </div>

  <script>
    // ---- Game state ----
    let deck = [];
    let discardPile = [];
    let playerHand = [];
    let cpuHand = [];
    let currentPlayer = "player";
    let isGameOver = false;

    // ---- Setup ----
    function createDeck() {
      const colors = ["red", "yellow", "green", "blue"];
      const newDeck = [];

      colors.forEach((color) => {
        // One zero per color
        newDeck.push({ color, value: 0, type: "number" });

        // Two of each 1â€“9 per color
        for (let v = 1; v <= 9; v++) {
          newDeck.push({ color, value: v, type: "number" });
          newDeck.push({ color, value: v, type: "number" });
        }

        // Two Skips, Reverses, +2 per color
        ["skip", "reverse", "draw2"].forEach((action) => {
          newDeck.push({ color, value: null, type: action });
          newDeck.push({ color, value: null, type: action });
        });
      });

      return newDeck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function drawOne() {
      // Recycle discard pile if needed
      if (deck.length === 0) {
        if (discardPile.length <= 1) return null; // no cards left at all
        const top = discardPile.pop();
        deck = discardPile;
        discardPile = [top];
        shuffle(deck);
      }
      return deck.pop();
    }

    function drawCards(target, count) {
      for (let i = 0; i < count; i++) {
        const card = drawOne();
        if (!card) return;
        if (target === "player") {
          playerHand.push(card);
        } else {
          cpuHand.push(card);
        }
      }
    }

    function canPlay(card, top) {
      if (!card || !top) return false;

      // Match color
      if (card.color === top.color) return true;

      // Match number
      if (card.type === "number" && top.type === "number" && card.value === top.value)
        return true;

      // Match action type
      if (card.type !== "number" && card.type === top.type) return true;

      return false;
    }

    function describeCard(card) {
      if (card.type === "number") return `${card.color} ${card.value}`;
      if (card.type === "draw2") return `${card.color} +2`;
      const name = card.type === "skip" ? "Skip" : "Reverse";
      return `${card.color} ${name}`;
    }

    function showMessage(text) {
      const statusEl = document.getElementById("status");
      statusEl.textContent = text;
    }

    // ---- Rendering ----
    function renderCard(card) {
      const el = document.createElement("div");
      el.classList.add("card", card.color);
      if (card.type !== "number") el.classList.add("action");

      let label;
      if (card.type === "number") {
        label = card.value;
      } else if (card.type === "skip") {
        label = "Skip";
      } else if (card.type === "reverse") {
        label = "Reverse";
      } else if (card.type === "draw2") {
        label = "+2";
      }

      const span = document.createElement("span");
      span.classList.add("value");
      span.textContent = label;
      el.appendChild(span);
      return el;
    }

    function updateUI() {
      const deckCountEl = document.getElementById("deckCount");
      const discardTopEl = document.getElementById("discardTop");
      const playerCardsEl = document.getElementById("playerCards");
      const cpuCardsEl = document.getElementById("cpuCards");
      const cpuCountEl = document.getElementById("cpuCount");
      const drawButton = document.getElementById("drawButton");

      deckCountEl.textContent = `${deck.length} card${deck.length === 1 ? "" : "s"} left`;

      // Discard top
      discardTopEl.innerHTML = "";
      const top = discardPile[discardPile.length - 1];
      if (top) {
        const topCardEl = renderCard(top);
        discardTopEl.appendChild(topCardEl);
      }

      // Player hand
      playerCardsEl.innerHTML = "";
      playerHand.forEach((card, index) => {
        const cardEl = renderCard(card);
        cardEl.classList.add("player-card");
        cardEl.dataset.index = index;
        cardEl.addEventListener("click", () => onPlayerCardClick(index));
        playerCardsEl.appendChild(cardEl);
      });

      // CPU hand (hidden, just backs)
      cpuCardsEl.innerHTML = "";
      cpuHand.forEach(() => {
        const backEl = document.createElement("div");
        backEl.classList.add("card", "back");
        backEl.textContent = "UNO";
        cpuCardsEl.appendChild(backEl);
      });

      cpuCountEl.textContent = cpuHand.length.toString();

      drawButton.disabled = currentPlayer !== "player" || isGameOver;
    }

    // ---- Turn / flow logic ----
    function checkWin() {
      if (playerHand.length === 0) {
        isGameOver = true;
        showMessage("You win!");
      } else if (cpuHand.length === 0) {
        isGameOver = true;
        showMessage("CPU wins!");
      }
    }

    function handleEndOfTurnEffects(card, playedBy) {
      if (isGameOver) return;

      const isAction =
        card.type === "skip" || card.type === "reverse" || card.type === "draw2";

      if (isAction) {
        const victim = playedBy === "player" ? "cpu" : "player";

        if (card.type === "draw2") {
          drawCards(victim, 2);
        }

        if (victim === "player") {
          showMessage("You were skipped!");
        } else {
          showMessage("CPU was skipped!");
        }

        // With 2 players: action cards make the same player go again
        if (playedBy === "cpu") {
          updateUI();
          setTimeout(cpuTurn, 600);
        } else {
          currentPlayer = "player";
          updateUI();
        }
      } else {
        // Normal card: pass turn
        currentPlayer = playedBy === "player" ? "cpu" : "player";
        if (currentPlayer === "cpu") {
          updateUI();
          setTimeout(cpuTurn, 600);
        } else {
          showMessage("Your turn");
          updateUI();
        }
      }
    }

    // ---- Player actions ----
    function onPlayerCardClick(index) {
      if (isGameOver || currentPlayer !== "player") return;

      const top = discardPile[discardPile.length - 1];
      const card = playerHand[index];

      if (!canPlay(card, top)) {
        showMessage("You can't play that card. Choose another or draw.");
        return;
      }

      const played = playerHand.splice(index, 1)[0];
      discardPile.push(played);

      showMessage("You played " + describeCard(played));
      checkWin();
      updateUI();
      if (isGameOver) return;

      handleEndOfTurnEffects(played, "player");
    }

    function onDrawClick() {
      if (isGameOver || currentPlayer !== "player") return;

      const drawn = drawOne();
      if (!drawn) {
        showMessage("No cards left to draw!");
        return;
      }

      playerHand.push(drawn);
      updateUI();

      const top = discardPile[discardPile.length - 1];

      if (canPlay(drawn, top)) {
        showMessage("You drew a playable card. Click it to play.");
      } else {
        showMessage("No playable card. CPU's turn.");
        currentPlayer = "cpu";
        setTimeout(cpuTurn, 600);
      }
    }

    // ---- CPU logic ----
    function cpuTurn() {
      if (isGameOver || currentPlayer !== "cpu") return;

      const top = discardPile[discardPile.length - 1];

      // Find first playable card
      let playableIndex = cpuHand.findIndex((card) => canPlay(card, top));

      if (playableIndex === -1) {
        // Draw one
        const drawn = drawOne();
        if (drawn) cpuHand.push(drawn);
        updateUI();

        if (drawn && canPlay(drawn, top)) {
          playableIndex = cpuHand.length - 1;
        } else {
          showMessage("CPU drew a card and couldn't play.");
          currentPlayer = "player";
          showMessage("Your turn");
          updateUI();
          return;
        }
      }

      // Play the card
      const played = cpuHand.splice(playableIndex, 1)[0];
      discardPile.push(played);
      showMessage("CPU played " + describeCard(played));
      checkWin();
      updateUI();
      if (isGameOver) return;

      handleEndOfTurnEffects(played, "cpu");
    }

    // ---- Game lifecycle ----
    function startGame() {
      deck = createDeck();
      shuffle(deck);
      discardPile = [];
      playerHand = [];
      cpuHand = [];
      isGameOver = false;
      currentPlayer = "player";

      // Deal 7 cards each
      for (let i = 0; i < 7; i++) {
        playerHand.push(drawOne());
        cpuHand.push(drawOne());
      }

      // Flip first card to start discard pile
      let first = drawOne();
      if (!first) {
        // Should never happen, but just in case
        first = { color: "red", value: 0, type: "number" };
      }
      discardPile.push(first);

      showMessage("Your turn");
      updateUI();
    }

    // ---- Event listeners ----
    document.getElementById("drawButton").addEventListener("click", onDrawClick);
    document.getElementById("newGameBtn").addEventListener("click", startGame);

    // Start immediately
    startGame();
  </script>
</body>
</html>
